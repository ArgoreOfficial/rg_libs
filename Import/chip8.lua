local ctx = {}

-- Helpers

local function clamp8(_value)  return bit32.band(_value, 0xFF) end
local function clamp16(_value) return bit32.band(_value, 0xFFFF) end

local function malloc(_size) 
	return 0 
end

local function get_ram(_byte) return ctx.RAM[_byte+1] end
local function set_ram(_byte, _value) ctx.RAM[_byte+1] = clamp8(_value) end

local function get_reg(_register) 
	return ctx.registers[_register+1] 
end

local function set_reg(_register, _value) 
	ctx.registers[_register+1] = clamp8(_value)
end

local function add_reg(_register, _value)
	ctx.registers[_register+1] = bit32.band((ctx.registers[_register+1] + _value), 0xFF)
end

local function pull4(_bits) return bit32.extract(_bits, 0, 4) end
local function pull8(_bits) return bit32.extract(_bits, 0, 8) end
local function pull12(_bits) return bit32.extract(_bits, 0, 12) end

local function fetch(_byte0, _byte1)
	return {
		bit32.extract(_byte0, 4, 4), -- 0xX___
		bit32.extract(_byte0, 0, 4), -- 0x_X__
		bit32.extract(_byte1, 4, 4), -- 0x__X_
		bit32.extract(_byte1, 0, 4)  -- 0x___X
	}
end

local function create_buffer(_length, _varsize)
	local buf = {}
	for i = 1, _length do
		buf[#buf+1] = malloc(_varsize)
	end
	return buf
end

local function write_table_to_ram(_at, _table)
	for i = 1, #_table do
		ctx.RAM[_at + i] = clamp8(_table[ i ])
	end
end

function ctx:load_program(_program)
	write_table_to_ram(0x200, _program)
end

local DISPLAY_WIDTH  = 64
local DISPLAY_HEIGHT = 32

-- Specifications
ctx.display = PixelData.new(DISPLAY_WIDTH, DISPLAY_HEIGHT, color.black)
ctx.RAM = create_buffer(4096, 1)
ctx.registers = { -- 16 8-bit registers
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1), 
	malloc(1)
}
ctx.DT = malloc(1) -- 8-bit
ctx.ST = malloc(1) -- 8-bit
ctx.I  = malloc(2) -- 16-bit
ctx.PC = malloc(2) -- program counter, 16-bit
ctx.SP = malloc(1) -- stack pointer, 8-bit
ctx.stack = {}
ctx.keys = {
	0,0,0,0,
	0,0,0,0,
	0,0,0,0,
	0,0,0,0
}
-- Instructions 

-- 00E0
function CLS()
	for y = 1, 32 do
		for x = 1, 64 do
			ctx.display:SetPixel(x, y, color.black)
		end
	end
end

-- 00EE
function RET()
	ctx.SP = ctx.SP - 1
	ctx.PC = ctx.stack[ctx.SP]
end

-- 1NNN
function JMP_NNN(_bits) 
	ctx.PC = bit32.extract(_bits, 0, 12)
end

-- 2NNN
function CALL_NNN(_bits)
	ctx.stack[ctx.SP] = ctx.PC
	ctx.SP = ctx.SP + 1

	ctx.PC = pull12(_bits)
end

-- 3XNN
function SE_VX_NN(_bits, _vx)
	if get_reg(_vx) == pull8(_bits) then
		ctx.PC = ctx.PC + 2
	end
end

-- 4XNN
function SNE_VX_NN(_bits, _vx)
	if get_reg(_vx) ~= pull8(_bits) then
		ctx.PC = ctx.PC + 2
	end
end

-- 5XY0
function SE_VX_VY(_bits, _vx, _vy)
	if get_reg(_vx) == get_reg(_vy) then
		ctx.PC = ctx.PC + 2
	end
end

-- 6XNN
function LD_VX_NN(_bits, _vx)
	set_reg(_vx, pull8(_bits))
end

-- 7XNN
function ADD_VX_NN(_bits, _vx)
	add_reg(_vx, pull8(_bits))
end

-- 8XY_
function ALU_OPS(_bits, _vx, _vy, _o)
	if _o == 0x0 then -- 8XY0
		-- LD VX, VY
		set_reg(_vx, get_reg(_vy))
	elseif _o == 0x1 then -- 8XY1
		-- OR VX, VY
		set_reg(_vx, bit32.bor(get_reg(_vx), get_reg(_vy)))
	elseif _o == 0x2 then -- 8XY2
		-- AND VX, VY
		set_reg(_vx, bit32.band(get_reg(_vx), get_reg(_vy)))
	elseif _o == 0x3 then -- 8XY3
		-- XOR VX, VY
		set_reg(_vx, bit32.bxor(get_reg(_vx), get_reg(_vy)))
	elseif _o == 0x4 then -- 8XY4
		-- ADD VX, VY
		local vx = get_reg(_vx)
		local vy = get_reg(_vy)
		set_reg(0xF, vx + vy > 0xFF and 1 or 0)
		set_reg(_vx, vx + vy)
	elseif _o == 0x5 then -- 8XY5
		-- SUB VX, VY
		local vx = get_reg(_vx)
		local vy = get_reg(_vy)
		set_reg(0xF, vx > vy and 1 or 0)
		set_reg(_vx, vx - vy)
	elseif _o == 0x6 then -- 8XY6
		-- SHR VX {, VY}
		local vx = get_reg(_vx)
		set_reg(0xF, bit32.band(vx, 0x01 ))
		set_reg(_vx, bit32.rshift(vx, 1))
	elseif _o == 0x7 then -- 8XY7
		-- SUBN VX, VY
		local vx = get_reg(_vx)
		local vy = get_reg(_vy)
		set_reg(0xF, vy > vx and 1 or 0)
		set_reg(_vx, vy - vx)
	elseif _o == 0xE then -- 8XYE
		-- SHL VX {, VY}
		local vx = get_reg(_vx)
		set_reg(0xF, bit32.band(vx, 0x80))
		set_reg(_vx, bit32.lshift(vx, 1))
	end
end

-- 9XY0
function SNE_VX_VY(_bits, _vx, _vy)
	if get_reg(_vx) ~= get_reg(_vy) then
		ctx.PC = ctx.PC + 2 
	end
end

-- ANNN
function LD_I_NNN(_bits)
	ctx.I = pull12(_bits)
end

-- BNNN
function JMP_V0_NNN(_bits)
	ctx.PC = clamp16(get_reg(0) + pull12(_bits))
end

-- CXNN
function RND_VX_NN(_bits, _vx)
	set_reg(_vx, bit32.band(math.random(0, 255), pull8(_bits)))
end

-- DXYN
function DRW_VX_VY_N(_bits, _vx, _vy, _n)
	local xcoord = get_reg(_vx) % DISPLAY_WIDTH
	local ycoord = get_reg(_vy) % DISPLAY_HEIGHT
	set_reg(0xF, 0)

	for row = 0, _n-1 do
		local bits = get_ram(clamp16(ctx.I + row))
		local cy = ycoord + row

		for col = 0, 7 do
			local cx = xcoord + col
			local bit = bit32.extract(bits, 7 - col)
			
			if bit > 0 then 
				local v = ctx.display:GetPixel(cx+1, cy+1) == color.white 
				if v then 
					set_reg(0xF, 1) 
					ctx.display:SetPixel(cx+1, cy+1, color.black)
				else
					ctx.display:SetPixel(cx+1, cy+1, color.white)
				end
			end

			if cx == DISPLAY_WIDTH - 1 then 
				break 
			end
		end

		if cy == DISPLAY_HEIGHT - 1 then 
			break 
		end
	end
end

-- EX__
function SKIP_VX(_bits, _vx)
	local op = pull8(_bits)
	if op == 0x9E then -- EX9E
		-- SKP VX
		if ctx.keys[_vx] == 1 then
			ctx.PC = ctx.PC + 2
		end
	elseif op == 0xA1 then -- EXA1
		-- SKNP VX
		if ctx.keys[_vx] == 1 then
			ctx.PC = ctx.PC + 2
		end
	end
end

-- FX__

local FX_ops = {
	[0x07] = function(_bits, _vx)
		set_reg(_vx, ctx.DT)
	end,

	[0x0A] = function(_bits, _vx)
		local k = wait_input()
		set_reg(_vx, k)
	end,

	[0x15] = function(_bits, _vx)
		ctx.DT = get_reg(_vx)
	end,

	[0x18] = function(_bits, _vx)
		ctx.ST = get_reg(_vx)
	end,
	
	[0x1E] = function(_bits, _vx)
		ctx.I = clamp16(ctx.I + get_reg(_vx))
	end,
	
	[0x29] = function(_bits, _vx)
		ctx.I = clamp16(get_reg(_vx) * 5)
	end,
	
	[0x33] = function(_bits, _vx)
		local vx = get_reg(_vx)
		local s = string.format("%03d", vx)
		
		local a = tonumber(s:sub(1,1))
		local b = tonumber(s:sub(2,2))
		local c = tonumber(s:sub(3,3))

		set_ram(ctx.I, a)
		set_ram(clamp16(ctx.I + 1), b)
		set_ram(clamp16(ctx.I + 2), c)
	end,
	
	[0x55] = function(_bits, _vx)
		for reg = 0, _vx do
			set_ram(ctx.I + reg, get_reg(reg))
		end
	end,

	[0x65] = function(_bits, _vx)
		for reg = 0, _vx do
			set_reg(reg, get_ram(ctx.I + reg))
		end
	end
}

function INTERRUPTS(_bits, _vx)
	local op = FX_ops[pull8(_bits)]
	if op then op(_bits, _vx) end
end

local opcodes = {
	[0x0] = {[0x0] = {[0xE] = {
		[0x0] = CLS, 
		[0xE] = RET
	}}},

	[0x1] = JMP_NNN,
	[0x2] = CALL_NNN,
	[0x3] = SE_VX_NN,
	[0x4] = SNE_VX_NN,
	[0x5] = SE_VX_VY,
	[0x6] = LD_VX_NN,
	[0x7] = ADD_VX_NN,
	[0x8] = ALU_OPS,
	[0x9] = SNE_VX_VY,
	[0xA] = LD_I_NNN,
	[0xB] = JMP_V0_NNN,
	[0xC] = RND_VX_NN,
	[0xD] = DRW_VX_VY_N,
	[0xE] = SKIP_VX,
	[0xF] = INTERRUPTS

}

local function run_op(_a, _b, _c, _d, _16bits)
	local a = opcodes[_a]
	if not a then return end
	if type(a) == "function" then a(_16bits, _b, _c, _d); return end

	local b = a[_b]
	if not b then return end
	if type(b) == "function" then b(_16bits, _c, _d); return end
	
	local c = b[_c]
	if not c then return end
	if type(c) == "function" then c(_16bits, _d); return end
	
	local d = c[_d]
	if not d then return end
	if type(d) == "function" then d(); return end
end

-- Initialization

-- Setup stack
for i = 1, 255 do 
	ctx.stack[#ctx.stack+1] = malloc(2)
end

-- Setup font data
write_table_to_ram(0x00, {
	0xF0, 0x90, 0x90, 0x90, 0xF0, -- 0
    0x20, 0x60, 0x20, 0x20, 0x70, -- 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, -- 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, -- 3
    0x90, 0x90, 0xF0, 0x10, 0x10, -- 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, -- 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, -- 6
    0xF0, 0x10, 0x20, 0x40, 0x40, -- 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, -- 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, -- 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, -- A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, -- B
    0xF0, 0x80, 0x80, 0x80, 0xF0, -- C
    0xE0, 0x90, 0x90, 0x90, 0xE0, -- D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, -- E
    0xF0, 0x80, 0xF0, 0x80, 0x80  -- F
})

ctx:load_program({ 
  0x12, 0x4e, 0xea, 0xac, 0xaa, 0xea, 0xce, 0xaa, 
  0xaa, 0xae, 0xe0, 0xa0, 0xa0, 0xe0, 0xc0, 0x40, 
  0x40, 0xe0, 0xe0, 0x20, 0xc0, 0xe0, 0xe0, 0x60, 
  0x20, 0xe0, 0xa0, 0xe0, 0x20, 0x20, 0x60, 0x40, 
  0x20, 0x40, 0xe0, 0x80, 0xe0, 0xe0, 0xe0, 0x20, 
  0x20, 0x20, 0xe0, 0xe0, 0xa0, 0xe0, 0xe0, 0xe0, 
  0x20, 0xe0, 0x40, 0xa0, 0xe0, 0xa0, 0xe0, 0xc0, 
  0x80, 0xe0, 0xe0, 0x80, 0xc0, 0x80, 0xa0, 0x40, 
  0xa0, 0xa0, 0xa2, 0x02, 0xda, 0xb4, 0x00, 0xee, 
  0xa2, 0x02, 0xda, 0xb4, 0x13, 0xdc, 0x68, 0x01, 
  0x69, 0x05, 0x6a, 0x0a, 0x6b, 0x01, 0x65, 0x2a, 
  0x66, 0x2b, 0xa2, 0x16, 0xd8, 0xb4, 0xa2, 0x3e, 
  0xd9, 0xb4, 0xa2, 0x02, 0x36, 0x2b, 0xa2, 0x06, 
  0xda, 0xb4, 0x6b, 0x06, 0xa2, 0x1a, 0xd8, 0xb4, 
  0xa2, 0x3e, 0xd9, 0xb4, 0xa2, 0x06, 0x45, 0x2a, 
  0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x0b, 0xa2, 0x1e, 
  0xd8, 0xb4, 0xa2, 0x3e, 0xd9, 0xb4, 0xa2, 0x06, 
  0x55, 0x60, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x10, 
  0xa2, 0x26, 0xd8, 0xb4, 0xa2, 0x3e, 0xd9, 0xb4, 
  0xa2, 0x06, 0x76, 0xff, 0x46, 0x2a, 0xa2, 0x02, 
  0xda, 0xb4, 0x6b, 0x15, 0xa2, 0x2e, 0xd8, 0xb4, 
  0xa2, 0x3e, 0xd9, 0xb4, 0xa2, 0x06, 0x95, 0x60, 
  0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x1a, 0xa2, 0x32, 
  0xd8, 0xb4, 0xa2, 0x3e, 0xd9, 0xb4, 0x22, 0x42, 
  0x68, 0x17, 0x69, 0x1b, 0x6a, 0x20, 0x6b, 0x01, 
  0xa2, 0x0a, 0xd8, 0xb4, 0xa2, 0x36, 0xd9, 0xb4, 
  0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x06, 0xa2, 0x2a, 
  0xd8, 0xb4, 0xa2, 0x0a, 0xd9, 0xb4, 0xa2, 0x06, 
  0x87, 0x50, 0x47, 0x2a, 0xa2, 0x02, 0xda, 0xb4, 
  0x6b, 0x0b, 0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x0e, 
  0xd9, 0xb4, 0xa2, 0x06, 0x67, 0x2a, 0x87, 0xb1, 
  0x47, 0x2b, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x10, 
  0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x12, 0xd9, 0xb4, 
  0xa2, 0x06, 0x66, 0x78, 0x67, 0x1f, 0x87, 0x62, 
  0x47, 0x18, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x15, 
  0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x16, 0xd9, 0xb4, 
  0xa2, 0x06, 0x66, 0x78, 0x67, 0x1f, 0x87, 0x63, 
  0x47, 0x67, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x1a, 
  0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x1a, 0xd9, 0xb4, 
  0xa2, 0x06, 0x66, 0x8c, 0x67, 0x8c, 0x87, 0x64, 
  0x47, 0x18, 0xa2, 0x02, 0xda, 0xb4, 0x68, 0x2c, 
  0x69, 0x30, 0x6a, 0x34, 0x6b, 0x01, 0xa2, 0x2a, 
  0xd8, 0xb4, 0xa2, 0x1e, 0xd9, 0xb4, 0xa2, 0x06, 
  0x66, 0x8c, 0x67, 0x78, 0x87, 0x65, 0x47, 0xec, 
  0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x06, 0xa2, 0x2a, 
  0xd8, 0xb4, 0xa2, 0x22, 0xd9, 0xb4, 0xa2, 0x06, 
  0x66, 0xe0, 0x86, 0x6e, 0x46, 0xc0, 0xa2, 0x02, 
  0xda, 0xb4, 0x6b, 0x0b, 0xa2, 0x2a, 0xd8, 0xb4, 
  0xa2, 0x36, 0xd9, 0xb4, 0xa2, 0x06, 0x66, 0x0f, 
  0x86, 0x66, 0x46, 0x07, 0xa2, 0x02, 0xda, 0xb4, 
  0x6b, 0x10, 0xa2, 0x3a, 0xd8, 0xb4, 0xa2, 0x1e, 
  0xd9, 0xb4, 0xa3, 0xe8, 0x60, 0x00, 0x61, 0x30, 
  0xf1, 0x55, 0xa3, 0xe9, 0xf0, 0x65, 0xa2, 0x06, 
  0x40, 0x30, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x15, 
  0xa2, 0x3a, 0xd8, 0xb4, 0xa2, 0x16, 0xd9, 0xb4, 
  0xa3, 0xe8, 0x66, 0x89, 0xf6, 0x33, 0xf2, 0x65, 
  0xa2, 0x02, 0x30, 0x01, 0xa2, 0x06, 0x31, 0x03, 
  0xa2, 0x06, 0x32, 0x07, 0xa2, 0x06, 0xda, 0xb4, 
  0x6b, 0x1a, 0xa2, 0x0e, 0xd8, 0xb4, 0xa2, 0x3e, 
  0xd9, 0xb4, 0x12, 0x48, 0x13, 0xdc 
})

ctx.PC = 0x200

function ctx.tick()
	if ctx.ST > 0 then ctx.ST = ctx.ST - 1 end
	if ctx.DT > 0 then ctx.DT = ctx.DT - 1 end

	local byte0 = get_ram(ctx.PC)
	ctx.PC = ctx.PC + 1
	local byte1 = get_ram(ctx.PC)
	ctx.PC = ctx.PC + 1

	local v = fetch(byte0, byte1)
	run_op(
		v[1], v[2], v[3], v[4], 
		bit32.bor(
			bit32.lshift(byte0, 8), 
			byte1
		))
end

return ctx